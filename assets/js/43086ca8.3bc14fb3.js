"use strict";(self.webpackChunkhyve_lang=self.webpackChunkhyve_lang||[]).push([[9318],{7075:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=t(4848),s=t(8453);const r={sidebar_position:5,description:"Functions in hyve"},a="Functions",o={id:"guide/functions",title:"Functions",description:"Functions in hyve",source:"@site/versioned_docs/version-0.0.1a/guide/functions.md",sourceDirName:"guide",slug:"/guide/functions",permalink:"/docs/0.0.1a/guide/functions",draft:!1,unlisted:!1,editUrl:"https://github.com/broken-bytes/Hyve-docs/versioned_docs/version-0.0.1a/guide/functions.md",tags:[],version:"0.0.1a",sidebarPosition:5,frontMatter:{sidebar_position:5,description:"Functions in hyve"},sidebar:"tutorialSidebar",previous:{title:"Control flow",permalink:"/docs/0.0.1a/guide/control-flow"},next:{title:"Enumerations",permalink:"/docs/0.0.1a/guide/enums"}},l={},c=[{value:"Reading functions",id:"reading-functions",level:2},{value:"Mutating functions",id:"mutating-functions",level:2},{value:"Parameters",id:"parameters",level:2}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"functions",children:"Functions"}),"\n",(0,i.jsxs)(n.p,{children:["In Hyve, there are two different types of functions, ",(0,i.jsx)(n.em,{children:"mutating"})," functions and ",(0,i.jsx)(n.em,{children:"reading"})," functions. By default, every functions is reading, disallowing mutation to its object."]}),"\n",(0,i.jsx)(n.h2,{id:"reading-functions",children:"Reading functions"}),"\n",(0,i.jsxs)(n.p,{children:["Reading functions are only used to calculate values, return properties etc. They cannot alter the state of their object but only ",(0,i.jsx)(n.em,{children:"read"})," it."]}),"\n",(0,i.jsx)(n.p,{children:"A reading function is defined like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hyve",children:'fn foo() -> String {\n    return ""\n}\n\nprint(foo())\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Always use reading functions when you don't need to alter state. It makes code more concise and allows understanding side effects more easily."})}),"\n",(0,i.jsx)(n.p,{children:"Functions may have parameters as well, like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hyve",children:'fn foo(bar: String) -> String {\n    return "Foo" + bar\n}\n\nprint(foo(bar: "Bar"))\n'})}),"\n",(0,i.jsx)(n.h2,{id:"mutating-functions",children:"Mutating functions"}),"\n",(0,i.jsx)(n.p,{children:"If the function has a side effect, e.g. it alters the state of its object, the function must be declared at mutating, otherwise the compiler disallows such mutations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hyve",children:"var value = 0\n\nmut fn foo() -> Int {\n    value += 1\n    return value\n}\n\n// Prints 1\nprint(foo())\n"})}),"\n",(0,i.jsx)(n.p,{children:"Just like reading functions, mutating functions can have parameters:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hyve",children:"var value = 0\n\nmut fn foo(newValue: Int) -> Int {\n    value = newValue\n    return value\n}\n\n// Prints 23\nprint(foo(newValue: 23))\n"})}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(n.p,{children:"Parameters have some specialities in Hyve as well. There are three different ways of passing parameters. By value, by reference and by pointer. Additionally, the mutability of these parameters is also defined in the function signature."}),"\n",(0,i.jsxs)(n.p,{children:["For this, there are two keywords in Hyve. ",(0,i.jsx)(n.code,{children:"mut"})," and ",(0,i.jsx)(n.code,{children:"mod"}),". Likewise, we can use the Pointer or Reference Syntax that is used for variables as well:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mut"})," Allows mutation of an object and the reference, which means that the pointer ",(0,i.jsx)(n.em,{children:"and"})," the object it points to may be changed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mod"})," Allows only mutation of the object, not the pointer"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Both keywords are applied to different parameter types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mut"})," May only be used alongside pointer parameters as these are the only parameter types that actually allow access to the pointer."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mod"})," May be used on either pointer or reference types as it indicates that the object may change."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If no modifier is applied, the object may neither change nor the pointer to it, resulting in a truly immutable parameter."}),"\n",(0,i.jsxs)(n.p,{children:["An example of a function having a ",(0,i.jsx)(n.code,{children:"mod"})," pointer parameter:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hyve",children:"fn foo(result: mod Int*, value1: Int, value2: Int) {\n    // Changes the underlying value of result, not the pointer\n    result = value1 + value2\n    // The compiler would throw an error here as result is not `mut` allowing only mutations to the object.\n    result = allocator.alloc(Int, 1)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["An example of a function having a ",(0,i.jsx)(n.code,{children:"mut"})," pointer parameter:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hyve",children:"fn foo(result: mut Int*, value1: Int, value2: Int) {\n    // Creates a new Int on the heap and assigns its pointer to result\n    result = allocator.alloc(Int, 1)\n    // Assigns the result of value1 + value2 to the underlying memory of result\n    result = value1 + value2\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["An example of a function having a ",(0,i.jsx)(n.code,{children:"mod"})," reference parameter:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hyve",children:"fn foo(result: mod Int&, value1: Int, value2: Int) {\n    // Assigns the result of value1 + value2 to the underlying memory of result\n    result = value1 + value2\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["In Hyve, everything is passed by value unless it is a pointer type. This means if passing by reference is desired, the ",(0,i.jsx)(n.code,{children:"&"})," reference syntax has to be used."]})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);